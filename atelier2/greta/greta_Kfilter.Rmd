---
title: "greta"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# What is greta
greta relies on TensorFlow and use efficient inference algorithms like Hamiltonian Monte Carlo. The main objective of greta is to provide a MCMC software like BUGS, JAGS or Stan. We can found on greta's [website](https://greta-dev.github.io/greta/index.html) the follwing definition:

- *simple : greta models are written right in R, so there’s no need to learn another language like BUGS or Stan*
- *scalable : greta uses Google TensorFlow so it’s fast even on massive datasets, and runs on CPU clusters and GPUs*
- *extensible : it’s easy to write your own R functions, modules, and even packages using greta*

The main advantage of greta is it builds statistical models interactively in R, and then sample from them by MCMC. There is no need to create a model object like in JAGS, Stan or nimble. However, greta creates specific objects (i.e. greta arrays) which are used to build the model and define the data to be used in the inference. greta is still is in its early developpement (version 0.2.3 on CRAN) and at this time their is a lack of documentation (especially compared with with Stan, JAGS or nimble).

## instalation
greta use TensorFlow and it needs to be installed before installing greta. 

```{r installation_TS, eval=FALSE, echo = TRUE, cache = FALSE, message = FALSE}
install.packages('tensorflow')
install_tensorflow()
```

greta also use the DiagrammeR R package for plotting Directed Acyclic Graph of greta models.

```{r installation_greta, echo = TRUE, cache = FALSE, message = FALSE}
# install.packages('greta')
# install.packages('DiagrammeR')
```

## How it works
On greta's website a getting started [page](https://greta-dev.github.io/greta/get_started.html) as well as [examples](https://greta-dev.github.io/greta/example_models.html) are availables. In the following section, we use greta with a simple dynamic model, for which there is no example on greta's website.

# Gaussian State Space model with greta
The latent process $X$ is assumed to be an independent random walk, which is a cumulative sum of a sequence of independent process errors $\epsilon_x$. 

$$X_{t} = \rho_x X_{t-1} + \epsilon_x \quad \text{with} \quad \epsilon_x \sim Normal(0, \sigma_x) $$
The observation process $Y$ is defined as:
$$Y_{t} = \rho_y X_{t} + \epsilon_y \quad \text{with} \quad \epsilon_y \sim Normal(0, \sigma_y) $$

## greta in practice
### packages loading
```{r packages_greta, cache = FALSE, message = FALSE}
library('greta')
library('MASS')
library('tidyverse')
library('DiagrammeR')
```

### Data simulation
```{r simulation_greta}
set.seed(123)

N <- 20 # number of time step
x_true <- rep(NA, N) # latent process
y <- rep(NA, N) # observations

# parameters
sd_x_true <- 1
sd_y_true <- 1
mean_x_init_true <- 0
r_x_true <- 0.85
r_y_true <- 1

### Process and data generation
x_true[1] <- rnorm(1, mean_x_init_true, sd_x_true)

y[1] <- rnorm(1, r_y_true*x_true[1], sd_y_true)

for (t in 2:N){
  x_true[t] <- rnorm(1, r_x_true*x_true[t-1], sd_x_true)
  y[t] <- rnorm(1, r_y_true*x_true[t], sd_y_true)
}
```

### greta data and priors


```{r greta1}
# greta's data 
obs <- as_data(y)

# priors
r_y <- gamma(1, 1) # gamma prior set to r_y
sd_x <- inverse_gamma(1, 1) # inv-gamma prior set to sd_x

# fixed parameters
sd_y <- sd_y_true # parameter fixed to the true value
r_x <- r_x_true # parameter fixed to the true value

# creation of an empty greta array
epsilon_x <- normal(0, sd_x, dim = N)
print(epsilon_x)
```

```{r greta1b}

# greta's data 
obs <- as_data(y)

# priors
r_y <- gamma(1, 1) # gamma prior set to r_y
sd_x <- inverse_gamma(1, 1) # inv-gamma prior set to sd_x

# fixed parameters
sd_y <- sd_y_true # parameter fixed to the true value
r_x <- r_x_true # parameter fixed to the true value

# creation of an empty greta array for the epsilon
epsilon_x <- normal(0, sd_x, dim = N)

# creation of an empty greta array for the X
X <- greta_array(data = 0, dim = c(N, 1))
# definition of the latent process interpreted by greta
for(t in 1:N){
  X[t, 1] <- sum(r_x^((t - 1) - (0:(t-1))) * epsilon_x[1:t, 1])
}
```

### greta model definition
```{r greta2}
# definition of the distribution of the observation
distribution(obs) <- normal(X * r_y, rep(sd_y, N), dim = N)
# greta's model building
model_greta <- model(X, r_y, sd_x, precision = 'double')
```
In this case study, greta faces numerical instability. The option *precision = 'double* of the model greta function redefines the model to have double precision and increase numerical stability, though this will slow down sampling. Once, the greta's model is built, greta in combination with the DiagrammeR package can generate a DAG representing the greta's model
```{r greta3, eval = FALSE}
plot(model_greta)
```
![DAG generated by greta](DAG.png)


## greta model inference
```{r greta4, echo = FALSE, eval = TRUE, include = FALSE}
if(file.exists('greta_draws.RData')){
} else {
  draws <- mcmc(model_greta, n_samples = 1000)
  save(draws, file = 'greta_draws.RData')
}
```

```{r greta4b, echo = TRUE, eval = FALSE}
# run sampler for 1000 iterations
draws <- greta::mcmc(model_greta, n_samples = 1000)
```

## greta model results
```{r greta5, echo = TRUE, include = FALSE, eval = TRUE}
load('greta_draws.RData')
```

Results of draws are retruned as an mcmc.list object and can be summarized with:
```{r greta6}
# print summary of mcmc.list
summary(draws)
```


```{r greta7, eval = TRUE, message = FALSE}
### extract data from mcmc.list object to tibble for easy plotting with ggplot2
bounds <- as_tibble(t(apply(draws[[1]][, -c(21, 22)],2,function(x) quantile(x,c(0.025,0.5,0.975)))))
bounds$param <- 1:N
colnames(bounds)[1:3] <- c("min","med","max")

ggdraws <- as_tibble(draws[[1]][, -c(21, 22)]) %>%
  gather(param, value) %>%
  mutate(param = as.numeric(str_extract(param, "[0-9]+")))

true <- as_tibble(data.frame(X=x_true,param=1:20))
obs <- as_tibble(data.frame(Y=y,param=1:20))
data <- left_join(ggdraws,bounds,by="param")
data <- left_join(data,true,by="param")
data <- left_join(data,obs,by="param")

### 
ggplot(data, aes(param, value)) +
  geom_point(size = 0.2) +
  geom_ribbon(aes(ymin = min, ymax = max), fill = "gold", alpha = 0.2) +
  geom_line(aes(param, X, colour = "col1"), size = 1) +
  geom_line(aes(param, Y, colour = "col2"), size = 0.6, linetype = "dashed") +
  geom_line(aes(param, med, colour= "col3"), size = 1.1) +
  scale_colour_manual(name = "",
                      values = c(col1 = "blue", col2 = "black", col3 = "violetred3"),
                      labels = c("True", "Observed", "Median estimate")) +
  labs (x = "Time", y = "Simulated values") +
  theme_bw() + ggtitle("Simulated data and their posterior distributions (black points).", subtitle = 'Yellow shade represents the CI at 95%')
```



## Comparison with nimble and jags

![](postSDX.png)
![](postRY.png)

![](effectiveSize.png)

## Conclusion
greta allows to perform inference with Hamiltonian Monte Carlo algorithm like Stan or nimble. Currently, the only implemented MCMC procedure in greta is static Hamiltonian Monte Carlo. In regards of our case study, greta give similar results than JAGS and nimble. However, its early version and the small amount of documentation do not allow (yet) the implementation of complex model. greta seems promising and its development is interesting to follow for users of MCMC software.


## Reference 
[https://greta-dev.github.io/greta/index.html](https://greta-dev.github.io/greta/index.html)